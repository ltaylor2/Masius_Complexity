
# Read in banding dataset
## Also note : 8200 (suspected females), 8300 (unknown sex), 8400 (suspected pre-def males)
# [Select] only ID (=Aluminum Band #), Date (=Date Banded), Sex, Age
# [Mutate] date column into Date object for sorting
# [Group by] ID
# [Slice Max] only the latest banding row for each ID, because some birds
#             were recapped and given updated band combos
#             in which case we want the most recent sex/age information
bands <- read_csv("Data/data_banding.csv", show_col_types=FALSE) |>
      select(Band_ID = "Alum#", Date="Date Banded", Sex, Age) |>
      mutate(Date = ymd(Date)) |>
      group_by(Band_ID) |>
      slice_max(order_by=Date, n=1, with_ties=FALSE)
      
# Custom function to categorize display types, 
#   Input: a UID for a display
#   Output: a dataframe mapping that UID to the display type
#           (SOLO, MULT, AUDI, COP)
# NOTE also does some error checking of original dataset w/r/t band numbers
# categorizeDisplayType <- function(uid) {
#     display <- filter(data_raw, UID==uid)

#     # Quick check to confirm there is only one ID for each ID column
#     maleID <- unique(display$Male1ID)
#     femID <- unique(display$FemID)
#     b2ID <- unique(display$Bird2ID)
#     b3ID <- unique(display$Bird3ID)

#     if (length(maleID) > 1 | length(femID) > 1 | length(b2ID) > 1 | length(b3ID) > 1) { 
#         cat(paste("\nERROR in Scripts/1_parse_data.r, categorizeDisplayType()\n",
#                   "Display UID", uid, "has multiple IDs in one of the ID columns"))
#     }

#     # Now get various data from the display to use in coding the type of display
#     hasFemOn <- "Female On Log" %in% display$FemOnOff
#     hasFemAction <- any(grepl("Female", display$Behavior))
#     hasAttCop <- "Attempted Copulation" %in% display$Behavior
#     hasCop <- "Copulation" %in% display$Behavior
#     hasB2Action <- any(grepl("Bird2", display$Behavior))

#     # TEMP data table with relevant info
#     ret <- tibble(UID=uid, maleID, femID, b2ID, b3ID, hasFemOn, hasFemAction, hasAttCop, hasCop, hasB2Action)
#     ret[is.na(ret)] <- ""
#     return(ret)
# }

# Custom function to end uncoded behavior strings at cop
# Returns original string if no Cop element present
cutDisplayAtCop <- function(s, coded=FALSE) {
	# If the behaviors are coded,
	#	we're cutting at behavior_code["Cop"] (should be "U")
	# If the behaviors are uncoded, 
	#	we're cutting at "Cop"
	if (coded) {
		copElement <- behavior_code["Cop"]
		ret <- strsplit(s, copElement)[[1]][1]
	} else {
		copElement <- ";Cop"
		ret <- strsplit(s, copElement)[[1]][1]
	}
	return(ret)
}

# Custom function to compute the compression ratio,
# where the ratio is given as length(s) : length(compressed(s))
# given brotli compression
# NOTE default brotli::brotli_compress values of quality=11 (max) and window=22
brotliCompressionRatio <- function(s) {
	raw_original <- charToRaw(s)
	length_original <- length(raw_original)

	raw_compressed <- brotli::brotli_compress(raw_original)
	length_compressed <- length(raw_compressed)

	compressionRatio <- length_original / length_compressed
	return(compressionRatio)
}

# Custom function to get mean local complexity
# across a rolling window from acss::local_complexity
# NOTE includes an error check that no string of length SPAN
# 		contains more than ALPHABET characters
# NOTE maximum acss::local_complexity values of alphabet=9 and span=12
# NOTE excludes NA returns acss::acss(), called through acss::local_complexity
meanLocalComplexity <- function(s, alphabet, span) {
	# ERROR CHECK -- do any substrings of length SPAN
	#	contain more than ALPHABET characters?
	start <- 1
	stop <- span

    # If the string is shorter than the window,
    #   set the window and span to be the length
    if (span > nchar(s)) { 
        stop <- nchar(s) 
        span <- nchar(s)
    }
	while (stop<=nchar(s)) {
		subs <- substr(s, start, stop)
		ncs <- countUniqueChars(subs)
		if (ncs > alphabet) {
			cat("\n\nERROR in Scripts/2_analyze.r (see meanLocalComplexity, acss::local_complexity):\nSome rolling window substrings for computing local complexity contain more than ALPHABET characters\n\nQUITTING\n\n")
			quit(save="no", status=1)
		}
		start <- start+1
		stop <- stop+1
	}

	# If we've made it through the error check,
	#	compute local complexity scores
	# Returns as a named vector
	lcs <- local_complexity(s, alphabet=alphabet, span=span)
	meanLC <- mean(lcs[[1]])

	if (is.na(meanLC)) {
		cat("\n\nERROR in Scripts/2_analyze.r (see meanLocalComplexity, acss::local_complexity):\nSome rolling window substrings for computing local complexity are returning NA values\n\nQUITTING\n\n")
		quit(save="no", status=1)
	}

	return(meanLC)
}





after_cop <- data_analyzed |>
        filter(Category == "COP") |>
        select(UID, Category, DisplayCode_AfterCop) |>
        separate(DisplayCode_AfterCop, into=as.character(0:max(data_analyzed$DisplayLength)),
                 sep="", fill="right") |>
        pivot_longer(-c(UID, Category), names_to="Index", values_to="Code") |>
        filter(Code!="" & !is.na(Code)) |>
        group_by(UID, Category, Code) |>
        tally() |>
        group_by(Category, Code) |>
        tally() |>
        select(Code, Category, N_Displays_with_Element=n) |>
        left_join(tally(group_by(data_analyzed, Category), name="Total_Displays_of_Category"), by="Category") |>
        mutate(Proportion_Displays_with_Element = N_Displays_with_Element / Total_Displays_of_Category) |>
        mutate(Percent_Displays_with_Element = round(Proportion_Displays_with_Element * 100,0)) |>
        select(Code, Perc=Percent_Displays_with_Element, N=N_Displays_with_Element) |>
        mutate(Element = map_chr(Code, ~ names(behavior_code)[behavior_code==.]),
               .after=Code)



# JARO DISTANCES ---------------------------------------------
# Jaro string distances
# uids <- data_clean |>
#      filter(Male1ID != 8000) |>
#      pull(UID)

# distMat <- matrix(data=NA, nrow=length(uids), ncol=length(uids),
#                   dimnames=list(uids, uids))

# for (r in 1:length(uids)) {
#     rID <- uids[r]
#     rD <- data_clean[data_clean$UID==rID,"DisplayCode"][[1]]
#     for (c in 1:length(uids)) {
#         cID <- uids[c]
#         cD <- data_clean[data_clean$UID==cID,"DisplayCode"][[1]]
#         dist <- stringdist(rD, cD, method="jw")
#         distMat[r,c] <- dist
#     }
# }
# getDistanceType <- function(d1_m, d1_type, d2_m, d2_type) {
#      distanceType <- "Diff Male / Diff Type"
#      if (d1_m == d2_m) {
#         if (d1_type == d2_type) {
#             distanceType <- "Same Male / Same Type"
#         } else {
#             distanceType <- "Same Male / Diff Type"
#         }
#      } else if (d1_type == d2_type) {
#         distanceType <- "Diff Male / Same Type"
#      }
#      return(distanceType)
# }
# distances <- distMat |>
#           as.data.frame() %>%
#           mutate(D1_UID=row.names(.)) |>
#           pivot_longer(cols=-D1_UID, names_to="D2_UID", values_to="Distance") |>
#           mutate(D1_Male1ID = map_chr(D1_UID, ~ data_clean[data_clean$UID==., "Male1ID"][[1]]),
#                  D1_DisplayType = map_chr(D1_UID, ~ data_clean[data_clean$UID==., "DisplayType"][[1]]),
#                  D2_Male1ID = map_chr(D2_UID, ~ data_clean[data_clean$UID==., "Male1ID"][[1]]),
#                  D2_DisplayType = map_chr(D2_UID, ~ data_clean[data_clean$UID==., "DisplayType"][[1]])) |>
#           mutate(DistanceType = pmap_chr(list(D1_Male1ID, D1_DisplayType, D2_Male1ID, D2_DisplayType), getDistanceType)) |>
#           filter(D1_UID != D2_UID)
# ggplot(distances) +
#     geom_boxplot(aes(x=DistanceType, y=Distance)) +
#     theme_bw() +
#     ylab("Jaro distance") +
#     theme(panel.grid=element_blank(),
#           axis.title.x=element_blank()) +
#     facet_grid(rows=vars(D1_DisplayType), 
#                cols=vars(D2_DisplayType)) 
